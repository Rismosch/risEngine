use chrono::Local;

use std::{fs::File, io::Write};

fn main() {
    create_build_info();
}

fn create_build_info() {
    const BUILD_INFO_PATH: &str = "./crates/ris_data/src/info/build_info.rs";

    let comment = build_comment();
    let body = build_content();

    let file_content = format!("{}\n{}", comment, body);
    let bytes = file_content.as_bytes();

    if let Ok(mut file) = File::create(BUILD_INFO_PATH) {
        let _ = file.write(bytes);
    }
}

fn build_comment() -> &'static str {
    "// DO NOT COMMIT CHANGES TO THIS FILE.\n// DO NOT MODIFY THIS FILE.\n// \n// THE CONTENTS OF THIS FILE ARE AUTOMATICALLY GENERATED BY `build.rs`.\n// \n// I highly recommend you run the following git command:\n// git update-index --assume-unchanged crates/ris_data/src/info/build_info.rs\n// \n// Doc: https://git-scm.com/docs/git-update-index#_using_assume_unchanged_bit\n"
}

fn build_content() -> String {
    let git_repo = run_process("git", vec!["config", "--get", "remote.origin.url"]);
    let git_commit = run_process("git", vec!["rev-parse", "--short", "HEAD"]);
    let git_branch = run_process("git", vec!["rev-parse", "--abbrev-ref", "HEAD"]);

    let rustc_version = run_process("rustc", vec!["--version"]);
    let rustup_toolchain = match std::env::var("RUSTUP_TOOLCHAIN") {
        Ok(toolchain) => toolchain,
        _ => run_process("rustup", vec!["show", "active-toolchain"]),
    };

    let build_time = Local::now();

    let content = format!(
        "use std::fmt;

#[derive(Clone, Eq, PartialEq, Hash, Debug)]
pub struct BuildInfo {{
    git_repo: String,
    git_commit: String,
    git_branch: String,
    rustc_version: String,
    rustup_toolchain: String,
    build_date: String,
}}

pub fn build_info() -> BuildInfo {{
    BuildInfo {{
        git_repo: String::from(\"{}\"),
        git_commit: String::from(\"{}\"),
        git_branch: String::from(\"{}\"),
        rustc_version: String::from(\"{}\"),
        rustup_toolchain: String::from(\"{}\"),
        build_date: String::from(\"{}\"),
    }}
}}

impl fmt::Display for BuildInfo {{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {{
        writeln!(f, \"Build\")?;
        writeln!(f, \"git repo:      {{}}\", self.git_repo)?;
        writeln!(f, \"git commit:    {{}}\", self.git_commit)?;
        writeln!(f, \"git branch:    {{}}\", self.git_branch)?;
        writeln!(f, \"compiler:      {{}}\", self.rustc_version)?;
        writeln!(f, \"toolchain:     {{}}\", self.rustup_toolchain)?;
        writeln!(f, \"build date:    {{}}\", self.build_date)?;

        Ok(())
    }}
}}
",
        git_repo, git_commit, git_branch, rustc_version, rustup_toolchain, build_time
    );

    content
}

fn run_process(program: &str, args: Vec<&str>) -> String {
    let result = || {
        let mut command = &mut std::process::Command::new(program);
        let mut command_line = String::from(program);

        for arg in args {
            command = command.arg(arg);
            command_line = format!("{} {}", command_line, arg);
        }

        let output = command
            .output()
            .map_err(|e| format!("Error while building `{}`: {}", command_line, e))?;
        let is_error = !output.stderr.is_empty();

        let output_bytes = if is_error {
            output.stderr
        } else {
            output.stdout
        };

        let output_string = String::from_utf8(output_bytes)
            .map_err(|e| format!("Error while formatting `{}`: {}", command_line, e))?;
        let result = output_string.trim_matches('\n');

        if is_error {
            Err(format!(
                "Error while running `{}`: {}",
                command_line, result
            ))
        } else {
            Ok(String::from(result))
        }
    };

    match result() {
        Ok(output) => output,
        Err(output) => output,
    }
}
